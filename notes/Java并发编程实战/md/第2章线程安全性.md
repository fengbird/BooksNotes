> 本章主要介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据

### 什么是线程安全性

#### 正确性

* 某个类的行为与其规范完全一致.

#### 线程安全性定义

* 当多个线程访问某个类时,这个类始终都能表现出正确的行为 , 那么就称这个类是线程安全的

### 原子性

#### 竞态条件

#### 示例:延迟初始化中的竞态条件

#### 复合操作

### 加锁机制

> 要保持状态的一致性,就需要在单个原子操作中更新所有相关的状态变量

#### 内置锁

* 每个Java对象都可以用做一个实现同步的锁 , 这些锁被称为内置锁(Intrinsic Lock)或监视器锁(Monitor Lock)
* Java的内置锁相当于一种互斥锁 , 这意味着最多只有一个线程能持有这种锁 . 当线程A尝试获取一个由线程B持有的锁时 , 线程A必须等待或者阻塞 , 直到线程B释放这个锁 . 如果B永远不释放锁, 那么A也将永远地等下去

#### 重入

> 当某个线程请求一个由其他线程持有的锁时 , 发出请求的线程就会阻塞 . 然而 , 由于内置锁是可重入的,因此如果某个线程视图获得一个已经由它自己持有的锁, 那么这个请求就会成功. "重入"意味着获取锁的操作的粒度是"线程" , 而不是 "调用"

### 用锁来保护状态

> 对于可能被多个线程同时访问的可变状态变量 , 在访问它时都需要哦持有同一个锁,在这种情况下,我们称状态变量是由这个锁保护的

* 一种常见的加锁约定是 , 将所有的可变状态都封装在对象内部 , 并通过对象的内置锁对所有访问可变状态的代码路径进行同步 , 使得在该对象上不会发生并发访问

### 活跃性与性能

* 不良并发应用程序
  * 可同时调用的数量 , 不仅受到可用处理资源的限制 , 还受到应用程序本身结构的限制