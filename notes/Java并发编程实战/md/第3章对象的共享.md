> 本章介绍如何共享和发布对象 , 从而使它们能够安全地由多个线程同时访问. 和第二章合在一起 , 就形成了构建线程安全类以及通过 java.util.concurrent 类库来构建并发应用程序的重要基础

* 同步的另一个重要的方面: 内存可见性(Memory Visibility) . 我们不仅希望防止某个线程正在使用对象状态而另一个线程再同时修改该状态 , 而且希望确保当一个线程修改了对象状态后 , 其他线程能够看到发生的状态变化 . 如果没有同步 , 那么这种情况就无法实现

### 可见性

* 在读操作和写操作在不同线程中执行时, 无法确保执行读操作的线程能适时地看到其他线程写入的值
* 在没有同步的情况下 , 编译器 , 处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整 . 在缺乏足够同步的多线程程序中 , 要想对内存操作的执行顺序进行判断 , 几乎无法得出正确的结论

#### 失效数据

* 当读线程查看变量时 , 可能会得到一个已经失效的值 . 除非在每次访问变量时都使用同步 , 否则很可能获得该变量的一个失效值 . 更糟糕的是 , 失效值可能不会同时出现: 一个线程可能获得某个变量的最新值 , 而获得另一个变量的失效值.

#### 非原子的64位操作

* Java内存模型要求, 变量的读取操作和写入操作都必须是原子操作 , 但对于非volatile类型的long和double变量 , JVM允许将64位的读操作或写操作分解为两个32位的操作 . 当读取一个非volatile类型的long变量时 , 如果对该变量的读操作和写操作在不同的线程中执行 , 那么很可能会读取到某个值的高32位和另一个值的低32位. 因此即使不考虑失效数据问题 , 在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的 , 除非用关键字volatile来声明它们 , 或者用锁保护起来

#### 加锁和可见性

* 加锁的含义不仅仅局限于互斥行为 , 还包括内存可见性 . 为了确保所有线程都能看到共享变量的最新值 , 所有执行读操作或者写操作的线程都必须在同一个锁上同步

#### Volatile变量

* Java语言提供了一种稍弱的同步机制 , 即volatile变量 , 用来确保变量的更新操作通知到其他线程 . 当把变量声明为volatile类型后 , 编译器与运行时都会注意到这个变量是共享的 , 因此不会将该变量上的操作与其他内存操作一起重排序 . volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方 , 因此在读取volatile类型的变量时总会返回最新写入的值





















































