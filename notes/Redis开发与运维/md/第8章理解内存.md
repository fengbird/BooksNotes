### 内存消耗

#### 内存使用统计

* 命令 `info memeory`
* 当mem_fragmentation_ratio>1时，说明used_memory_rss-used_memory多出的部分内存并没有用于数据存储，而是被内存碎片所消耗，如果两者相差很大，说明碎片率严重。
* 当mem_fragmentation_ratio<1时，这种情况一般出现在操作系统把Redis内存交换（Swap）到硬盘导致，出现这种情况时要格外关注，由于硬盘速度远远慢于内存，Redis性能会变得很差，甚至僵死。

#### 内存消耗划分

* 自身内存+对象内存+缓冲内存+内存碎片
* 对象内存
  * 是Redis内存占用最大的一块,存储着用户所有的数据.
* 缓冲内存
  * 客户端缓冲 复制积压缓冲区 AOF缓冲区
* 内存碎片
  * Redis默认的内存分配器采用jemalloc
  * 容易出现高内存碎片的原因:
    * 频繁做更新操作,例如频繁对已存在的键执行append、setrange等更新操作
    * 大量过期键删除,键对象过期删除后,释放的空间无法得到充分利用,导致碎片率上升
  * 解决方式
    * 数据对齐: 在条件允许的情况下尽量做数据对齐，比如数据尽量采用数字类型或者固定长度字符串等，但是这要视具体的业务而定，有些场景无法做到。
    * 安全重启: 重启节点可以做到内存碎片重新整理，因此可以利用高可用架构，如Sentinel或Cluster，将碎片率过高的主节点转换为从节点，进行安全重启。

#### 子进程内存消耗

* Redis产生的子进程并不需要消耗1倍的父进程内存,实际消耗根据期间写入命令量决定,但是依然要预留出一些内存防止溢出
* 需要设置 sysctl vm.`overcommit_memory=1` 允许内核可以分配所有的物理内存，防止Redis进程执行fork时因系统剩余内存不足而失败
* 排查当前系统是否支持并开启THP，如果开启建议关闭，防止copy-on-write期间内存过度消耗

### 内存管理

#### 设置内存上限

* 使用 `maxmemory` 参数限制最大可用内存

#### 动态调整内存上限

#### 内存回收策略

### 内存优化

#### redisObject对象

#### 缩减键值对象

#### 共享对象池

#### 字符串优化

#### 编码优化

#### 控制键的数量