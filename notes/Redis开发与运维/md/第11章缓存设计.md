### 缓存的收益和成本

#### 收益

* 加速读写: 因为缓存通常都是全内存的(例如Redis , Memcache) , 而存储层通常读写性能不够强悍(例如MySQL) , 通过缓存的使用可以有效的加速读写 , 优化用户体验
* 降低后端负载: 帮助后端减少访问量和复杂计算 (例如很复杂的SQL语句) , 在很大程度上降低了后端的负载

#### 成本

* 数据不一致性: 缓存层和存储层的数据存在着一定时间窗口的不一致性 , 时间窗口和更新策略有关.
* 代码维护成本: 加入缓存后, 需要同时处理缓存层和存储层的逻辑 , 增大了开发者维护代码的成本
* 运维成本: 以Redis Cluster为例 , 加入后无形中增加了运维成本

#### 使用场景

* 开销大的复杂计算
* 加速请求响应

### 缓存更新策略

#### LRU/LFU/FIFO算法剔除

* 使用场景
  * 剔除算法通常用于缓存使用量超过了预设的最大值时候，如何对现有的数据进行剔除。例如Redis使用maxmemory-policy这个配置作为内存最大值后对于数据的剔除策略。
* 一致性
  * 要清理哪些数据是由具体算法决定，开发人员只能决定使用哪种算法，所以数据的一致性是最差的
* 维护成本
  * 算法不需要开发人员自己来实现，通常只需要配置最大maxmemory和对应的策略即可。开发人员只需要知道每种算法的含义，选择适合自己的算法即可

#### 超时剔除

* 使用场景
  * 超时剔除通过给缓存数据设置过期时间，让其在过期时间后自动删除，例如Redis提供的expire命令
* 一致性
  * 一段时间窗口内（取决于过期时间长短）存在一致性问题，即缓存数据和真实数据源的数据不一致。
* 维护成本。维护成本不是很高，只需设置expire过期时间即可，当然前提是应用方允许这段时间可能发生的数据不一致

#### 主动更新

* 使用场景
  * 应用方对于数据的一致性要求高，需要在真实数据更新后，立即更新缓存数据。例如可以利用消息系统或者其他方式通知缓存更新
* 一致性
  * 一致性最高，但如果主动更新发生了问题，那么这条数据很可能很长时间不会更新，所以建议结合超时剔除一起使用效果会更好
* 维护成本
  * 维护成本会比较高，开发者需要自己来完成更新，并保证更新操作的正确性

#### 最佳实践

* 低一致性业务建议配置最大内存和淘汰策略的方式使用
* 高一致性业务可以结合使用超时剔除和主动更新 , 这样即使主动更新出了问题 , 也能保证数据过期时间后删除脏数据

### 缓存力度控制

* 通用性
  * 缓存全部数据比部分数据更加通用 , 但从实际经验看 ,很长时间内应用只需要几个重要的属性
* 空间占用
  * 缓存全部数据要比部分数据占用更多的空间 , 可能存在以下问题:
    * 全部数据会造成内存的浪费
    * 全部数据可能每次传输产生的网络流传会比较大 , 耗时相对较大 , 在极端情况下会阻塞网络
    * 全部数据的序列化和反序列化的CPU开销更大
* 代码维护
  * 全部数据的优势更加明显 , 而部分数据一旦要加新字段需要修改业务代码 , 而修改后通常还需要刷新缓存数据

### 穿透优化

> 缓存穿透是指查询一个根本不存在的数据 , 缓存层和存储层都不会命中 , 将导致不存在的数据每次请求都要到存储层去查询 , 失去了缓存保护后端存储的意义

* 造成缓存穿透的基本原因
  * 自身业务代码或者数据出现问题
  * 一些恶意攻击 , 爬虫等造成大量空命中

#### 优化方案

1. 缓存空对象
   * 缓存空对象会有两个问题：第一，空值做了缓存，意味着缓存层中存了
     更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的
     方法是针对这类数据设置一个较短的过期时间，让其自动剔除。第二，缓存
     层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。
     例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间
     就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方
     式清除掉缓存层中的空对象
2. 布隆过滤器拦截

### 无底洞优化

> 随着业务需求添加更多的缓存节点 , 但是性能不但没有好转反而下降的现象 被称为无底洞现象

#### 产生原因

* 客户端一次批量操作会涉及多次网络操作 , 也就意味着批量操作会随着节点的增多 , 耗时会不断增大
* 网络连接数变多 , 对节点的性能也有一定影响

#### 解决方案

* 串行命令
* 串行IO
* 并行IO
* hash_tag

### 雪崩优化

> 由于缓存层承载着大量请求 , 有效地保护了存储层 , 但是如果缓存层由于某些原因不能提供服务 , 于是所有的请求都会达到存储层 , 存储层的调用量会暴增 , 造成存储层也会级联宕机的情况

#### 解决方案

* 保证缓存层服务高可用性
* 依赖隔离组件为后端限流并降级
* 提前演练

### 热点key重建优化

* 互斥锁(mutex key)
  * 只允许一个线程重建缓存 , 其他线程等待重建缓存的线程执行完, 重新从缓存获取数据即可
* 永不过期