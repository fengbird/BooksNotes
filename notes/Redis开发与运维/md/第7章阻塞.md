### 内在原因

#### API或数据结构使用不合理

* 发现慢查询
  * 执行slowlog get {n} 获取最近的n条慢查询命令
* 调整
  * 修改为低算法度的命令,如`hgetall`改为`hmget`等,禁用keys , sort 等命令
  * 调整大对象: 缩减大对象数据或把大对象拆分为多个小对象,放置一次命令操作过多的数据 . 
* 发现大对象
  * 命令 redis-cli -h {ip} -p {port} bigkeys

#### CPU饱和

* 先判断当前Redis的并发量是否达到极限,使用统计命令 `redis-cli -h {ip} -p {port} --stat` 获取当前Redis使用情况

#### 持久化阻塞

* fork阻塞
  * 发生于RDB和AOF重写时
  * 可执行`info stats` 获取到 `latest_fork_usec` 指标,表示Redis最近一次fork操作耗时
* AOF刷盘阻塞
  * 当开启AOF后, 文件刷盘的方式一般采用每秒一次,后台线程每秒对AOF文件做fsync操作。 当硬盘压力过大时,fsync操作需要等待,直到写入完成 . 因此若硬盘压力过大会导致该操作阻塞
  * 可以使用 `iotop` 查看具体是哪个进程消耗过多的硬盘资源
* HugePage写操作阻塞
  * 子进程在执行重写期间利用Linux写时复制技术降低内存开销，因此只
    有写操作时Redis才复制要修改的内存页。对于开启Transparent HugePages的操作系统，每次写命令引起的复制内存页单位由4K变为2MB，放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询。

### 外在原因

#### CPU竞争

* 进程竞争
* 绑定CPU

#### 内存交换

#### 网络问题

* 连接拒绝
  * 网络闪断
  * Redis连接拒绝
  * 连接溢出
* 网络延迟

* 网卡软中断