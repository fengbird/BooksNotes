### 数据分布

> Redis Cluster 是Redis的分布式解决方案 , 有效地解决了Redis分布式方面的需求 . 当遇到单机内存 , 并发 , 流量等瓶颈时 , 可以采用Cluster架构方案达到负载均衡的目的

#### 数据分布理论

* 分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题 , 即把数据集划分到多个节点上, 每个节点负责整体数据的一个子集
* 常见的分区规则有哈希分区和顺序分区两种
* Redis Cluster采用的是哈希分区规则
* 哈希分区规则
  * 节点取余分区
  * 一致性哈希分区
  * 虚拟槽分区

#### Redis数据分区

* Redis Cluster 采用虚拟槽分区 , 所有的键根据哈希函数映射到0~16383整数槽内 , 计算公式: slot=CRC16(key) & 16383 . 每一个节点负责维护一部分槽以及槽所映射的键值数据
* Redis虚拟槽分区的特点
  * 解耦数据和节点之间的关系 , 简化了节点扩容和收缩难度
  * 节点自身维护槽的映射关系 , 不需要客户端或者代理服务维护槽分区元数据
  * 支持节点 , 槽 ,键之间的映射查询 , 用于数据路由 , 在线伸缩等场景

#### 集群功能限制

* key批量操作支持有限
* key事务操作支持有限
* key作为数据分区的最小粒度 , 因此不能将一个大的键值对象如hash , list 等映射到不同的节点
* 不支持多数据库空间
* 复制结构只支持一层, 从节点只能复制主节点 , 不支持嵌套树状复制结构

### 搭建集群

* 可通过 cluster nodes 查看集群状态和复制关系 还有cluster info查看集群状态

#### 准备节点

* Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。

#### 节点握手

* 节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信 , 达到感知对方的过程 , 节点握手是集群彼此通信的第一步 , 由客户端发起命令: cluster meet {ip} {port}

#### 分配槽

- Redis集群把所有的数据映射到16384个槽中 . 每个key会映射为一个固定的槽 , 只有当结点分配了槽, 才能响应和这些槽关联的键命令 . 通过 cluster addslots {槽范围} 命令为节点分配槽
- 得到分配槽的节点为主节点 , 作为一个完整的集群 , 每个负责处理槽的节点应该具有从节点 , 保证当它出现故障时可以自动进行故障转移 . 在对应的从节点上执行 cluster replicate {nodeId} 命令让一个节点成为从节点 , nodeId是要复制主节点的节点ID

#### 用redis-trib.rb搭建集群

### 节点通信

#### 通信流程

1. 集群中的每个节点都会单独开辟一个TCP通道 , 用于节点之间彼此通信 , 通信端口号在基础端口上加10000.
2. 每个节点在固定周期内通过特定规则选择几个节点发送ping消息
3. 接收到ping消息的节点用pong消息作为响应.

#### Gossip消息

* Gossip(流言)协议的主要职责就是信息交换 . 信息交换的载体就是节点彼此发送的Gossip消息
* 常用的Gossip消息可分为: ping消息 , pong消息 , meet消息 , fail消息等

#### 节点选择

### 集群伸缩

#### 伸缩原理

* 集群的水平伸缩的上层原理: 集群伸缩=槽和数据在节点之间的移动

#### 扩容集群

* 准备新节点
* 加入集群
* 迁移槽和数据

#### 收缩集群

* 首先需要确定下线节点是否有负责的槽 , 如果是 , 需要把槽迁移到其他节点 , 保证节点下线后整个集群槽节点映射的完整性
* 当下线节点不再负责槽或者本身是从节点时 , 就可以通知集群内其他节点忘记下线节点 , 当所有的节点忘记该节点后可以正常关闭

### 请求路由

#### 请求重定向

#### Smart客户端

#### ASK重定向

### 故障转移

#### 故障发现

#### 故障恢复

#### 故障转移时间

#### 故障转移演练

### 集群运维

#### 集群完整性

#### 带宽消耗

#### Pub/Sub广播问题

#### 集群倾斜

#### 集群读写分离

#### 手动故障转移

#### 数据转移

